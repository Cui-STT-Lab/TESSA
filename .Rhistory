}
if(LOO){
if("DP_genes" %in% names(object@result[[lineage]])){
DP_genes <- object@result[[lineage]]$DP_genes
}else{
DP_genes <- intersect(genes, object@signature_genes)
}
}
res_list <- list()
for(K_test_name in c( 'kernel_S', 'kernel_T')){
res <- lapply(genes, function(gene){
if(LOO & (K_test_name == 'kernel_T') & (gene %in% DP_genes)){
## only run LOO on TVGs detection, if this gene is used to estimate pseudotime
loc_df = meta_df
signature_genes <- setdiff(object@signature_genes, gene)
embedding <- prcomp_irlba(t(Y[signature_genes, ,drop = FALSE]), scale. = TRUE, n = npcs)$x
sim <- SingleCellExperiment(assays = Y,
reducedDims = SimpleList(PCA = embedding),
colData = DataFrame(clusterlabel = rep("0", ncol(Y)) )
)
sim  <- slingshot(sim, clusterLabels = 'clusterlabel', reducedDim = 'PCA',start.clus="0" )
loc_df[, lineage] = sim@colData@listData$slingPseudotime_1
object_loo <- CreateTessaObject(counts = Y[gene,,drop = FALSE ], meta_df = loc_df,
signature_genes =  signature_genes,
covariates = object@covariates, normalized = object@normalized )
object <- build_kernelMatrix(object_loo, bw = object@bandwidth)
test2_out <- Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}else{
test2_out <-Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}
test2_out
})
res <-  cbind( unlist(lapply(res, function(x){ x$p.value})),
unlist(lapply(res, function(x){ x$gene})) )
colnames(res) <-  c(K_test_name, 'geneid')
res_list[[K_test_name]] <- res
}
res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
dplyr::rename('kernel_T' = 'TVG_pvs', 'kernel_S' = 'SVG_pvs') %>%
mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
object@result[[lineage]][['Test2']] <- res_df[,c('geneid', 'TVG_pvs', 'TVG_pvs_adj', 'SVG_pvs', 'SVG_pvs_adj')]
object
}
devtools::install()
knitr::opts_chunk$set(echo = TRUE)
library(TESSA)
library(ggplot2)
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SingleCellExperiment")
load('./data/PDAC_S2A.rda')
Tessa.obj =  CreateTessaObject(counts = counts, meta_df = meta_df,
signature_genes = mkgenes,
covariates = NULL, normalized = FALSE)
Tessa.obj = data_preprocess(object = Tessa.obj, spot.threshold = 10, gene.threshold = 0.1)
Tessa.obj = build_kernelMatrix(Tessa.obj)
system.time(
Tessa.obj <-  run_Test1(Tessa.obj,LOO = F, npcs = 10)
)
## set npcs to a rational number automatically later
system.time(
Tessa.obj <-  run_Test1(Tessa.obj, LOO = TRUE, npcs = 10)
)
uTSVGs_result <- get_Test1_result(Tessa.obj)
head(uTSVGs_result)
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
uTSVGs_result <- get_Test1_result(Tessa.obj)
head(uTSVGs_result)
Test1_result_sig <- Test1_result[Test1_result$pvs_adj_LOO < 0.05, ]
uTSVGs_result <- get_Test1_result(Tessa.obj) %>% filter(pvs_adj_LOO < 0.05)
library(TESSA)
library(dplyr)
library(ggplot2)
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SingleCellExperiment")
uTSVGs_result <- get_Test1_result(Tessa.obj) %>% filter(pvs_adj_LOO < 0.05)
head(uTSVGs_result)
uTSVGs_list <- split(Test1_result_sig$geneid, Test1_result_sig$lineage)
uTSVGs_list <- split(uTSVGs_result$geneid, uTSVGs_result$lineage)
str(uTSVGs_list)
run_Test2_lineage = function(object, lineage = 'lineage1', genes = NULL, LOO = FALSE,npcs = 30){
meta_df <- na.omit(object@meta_df[,c('x','y',lineage,'Sample_ID')])
Y <- object@gene_expression[,colnames(object@gene_expression)[match(rownames(meta_df), colnames(object@gene_expression))],drop = FALSE]
if(!is.null(genes)){
cat('run Test2 on user defined ', length(genes) ,' uTSVGs on all lineages', '\n')
}else{
Test1_result <- get_Test1_result(object,lineage = lineage)
if('pvs_adj_LOO' %in% colnames(Test1_result)){
genes <- Test1_result$geneid[Test1_result$pvs_adj_LOO < 0.05 ]
cat('run Test2 on', length(genes) ,'uTSVGs', '\n')
}else{
genes <- Test1_result$geneid[Test1_result$pvs_adj < 0.05, ]
cat('run Test2 on', length(genes) ,'uTSVGs without double dipping correction', '\n')
}
}
if(LOO){
if("DP_genes" %in% names(object@result[[lineage]])){
DP_genes <- object@result[[lineage]]$DP_genes
}else{
DP_genes <- intersect(genes, object@signature_genes)
}
}
res_list <- list()
for(K_test_name in c( 'kernel_S', 'kernel_T')){
res <- lapply(genes, function(gene){
if(LOO & (K_test_name == 'kernel_T') & (gene %in% DP_genes)){
## only run LOO on TVGs detection, if this gene is used to estimate pseudotime
loc_df = meta_df
signature_genes <- setdiff(object@signature_genes, gene)
embedding <- prcomp_irlba(t(Y[signature_genes, ,drop = FALSE]), scale. = TRUE, n = npcs)$x
sim <- SingleCellExperiment(assays = Y,
reducedDims = SimpleList(PCA = embedding),
colData = DataFrame(clusterlabel = rep("0", ncol(Y)) )
)
sim  <- slingshot(sim, clusterLabels = 'clusterlabel', reducedDim = 'PCA',start.clus="0" )
loc_df[, lineage] = sim@colData@listData$slingPseudotime_1
object_loo <- CreateTessaObject(counts = Y[gene,,drop = FALSE ], meta_df = loc_df,
signature_genes =  signature_genes,
covariates = object@covariates, normalized = object@normalized )
object <- build_kernelMatrix(object_loo, bw = object@bandwidth)
test2_out <- Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}else{
test2_out <-Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}
test2_out
})
res <-  cbind( unlist(lapply(res, function(x){ x$p.value})),
unlist(lapply(res, function(x){ x$gene})) )
colnames(res) <-  c(K_test_name, 'geneid')
res_list[[K_test_name]] <- res
}
res_list
# res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
#   dplyr::rename('kernel_T' = 'TVG_pvs', 'kernel_S' = 'SVG_pvs') %>%
#   mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
#          SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
# object@result[[lineage]][['Test2']] <- res_df[,c('geneid', 'TVG_pvs', 'TVG_pvs_adj', 'SVG_pvs', 'SVG_pvs_adj')]
# object
}
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
run_Test2_lineage = function(object, lineage = 'lineage1', genes = NULL, LOO = FALSE,npcs = 30){
meta_df <- na.omit(object@meta_df[,c('x','y',lineage,'Sample_ID')])
Y <- object@gene_expression[,colnames(object@gene_expression)[match(rownames(meta_df), colnames(object@gene_expression))],drop = FALSE]
if(!is.null(genes)){
cat('run Test2 on user defined ', length(genes) ,' uTSVGs on all lineages', '\n')
}else{
Test1_result <- get_Test1_result(object,lineage = lineage)
if('pvs_adj_LOO' %in% colnames(Test1_result)){
genes <- Test1_result$geneid[Test1_result$pvs_adj_LOO < 0.05 ]
cat('run Test2 on', length(genes) ,'uTSVGs', '\n')
}else{
genes <- Test1_result$geneid[Test1_result$pvs_adj < 0.05, ]
cat('run Test2 on', length(genes) ,'uTSVGs without double dipping correction', '\n')
}
}
if(LOO){
if("DP_genes" %in% names(object@result[[lineage]])){
DP_genes <- object@result[[lineage]]$DP_genes
}else{
DP_genes <- intersect(genes, object@signature_genes)
}
}
res_list <- list()
for(K_test_name in c( 'kernel_S', 'kernel_T')){
res <- lapply(genes, function(gene){
if(LOO & (K_test_name == 'kernel_T') & (gene %in% DP_genes)){
## only run LOO on TVGs detection, if this gene is used to estimate pseudotime
loc_df = meta_df
signature_genes <- setdiff(object@signature_genes, gene)
embedding <- prcomp_irlba(t(Y[signature_genes, ,drop = FALSE]), scale. = TRUE, n = npcs)$x
sim <- SingleCellExperiment(assays = Y,
reducedDims = SimpleList(PCA = embedding),
colData = DataFrame(clusterlabel = rep("0", ncol(Y)) )
)
sim  <- slingshot(sim, clusterLabels = 'clusterlabel', reducedDim = 'PCA',start.clus="0" )
loc_df[, lineage] = sim@colData@listData$slingPseudotime_1
object_loo <- CreateTessaObject(counts = Y[gene,,drop = FALSE ], meta_df = loc_df,
signature_genes =  signature_genes,
covariates = object@covariates, normalized = object@normalized )
object <- build_kernelMatrix(object_loo, bw = object@bandwidth)
test2_out <- Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}else{
test2_out <-Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}
test2_out
})
res <-  cbind( unlist(lapply(res, function(x){ x$p.value})),
unlist(lapply(res, function(x){ x$gene})) )
colnames(res) <-  c(K_test_name, 'geneid')
res_list[[K_test_name]] <- res
}
res_list
# res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
#   dplyr::rename('kernel_T' = 'TVG_pvs', 'kernel_S' = 'SVG_pvs') %>%
#   mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
#          SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
# object@result[[lineage]][['Test2']] <- res_df[,c('geneid', 'TVG_pvs', 'TVG_pvs_adj', 'SVG_pvs', 'SVG_pvs_adj')]
# object
}
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
run_Test2_lineage = function(object, lineage = 'lineage1', genes = NULL, LOO = FALSE,npcs = 30){
meta_df <- na.omit(object@meta_df[,c('x','y',lineage,'Sample_ID')])
Y <- object@gene_expression[,colnames(object@gene_expression)[match(rownames(meta_df), colnames(object@gene_expression))],drop = FALSE]
if(!is.null(genes)){
cat('run Test2 on user defined ', length(genes) ,' uTSVGs on all lineages', '\n')
}else{
Test1_result <- get_Test1_result(object,lineage = lineage)
if('pvs_adj_LOO' %in% colnames(Test1_result)){
genes <- Test1_result$geneid[Test1_result$pvs_adj_LOO < 0.05 ]
cat('run Test2 on', length(genes) ,'uTSVGs', '\n')
}else{
genes <- Test1_result$geneid[Test1_result$pvs_adj < 0.05, ]
cat('run Test2 on', length(genes) ,'uTSVGs without double dipping correction', '\n')
}
}
if(LOO){
if("DP_genes" %in% names(object@result[[lineage]])){
DP_genes <- object@result[[lineage]]$DP_genes
}else{
DP_genes <- intersect(genes, object@signature_genes)
}
}
res_list <- list()
for(K_test_name in c( 'kernel_S', 'kernel_T')){
res <- lapply(genes, function(gene){
if(LOO & (K_test_name == 'kernel_T') & (gene %in% DP_genes)){
## only run LOO on TVGs detection, if this gene is used to estimate pseudotime
loc_df = meta_df
signature_genes <- setdiff(object@signature_genes, gene)
embedding <- prcomp_irlba(t(Y[signature_genes, ,drop = FALSE]), scale. = TRUE, n = npcs)$x
sim <- SingleCellExperiment(assays = Y,
reducedDims = SimpleList(PCA = embedding),
colData = DataFrame(clusterlabel = rep("0", ncol(Y)) )
)
sim  <- slingshot(sim, clusterLabels = 'clusterlabel', reducedDim = 'PCA',start.clus="0" )
loc_df[, lineage] = sim@colData@listData$slingPseudotime_1
object_loo <- CreateTessaObject(counts = Y[gene,,drop = FALSE ], meta_df = loc_df,
signature_genes =  signature_genes,
covariates = object@covariates, normalized = object@normalized )
object <- build_kernelMatrix(object_loo, bw = object@bandwidth)
test2_out <- run_Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}else{
test2_out <-run_Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}
test2_out
})
res <-  cbind( unlist(lapply(res, function(x){ x$p.value})),
unlist(lapply(res, function(x){ x$gene})) )
colnames(res) <-  c(K_test_name, 'geneid')
res_list[[K_test_name]] <- res
}
res_list
# res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
#   dplyr::rename('kernel_T' = 'TVG_pvs', 'kernel_S' = 'SVG_pvs') %>%
#   mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
#          SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
# object@result[[lineage]][['Test2']] <- res_df[,c('geneid', 'TVG_pvs', 'TVG_pvs_adj', 'SVG_pvs', 'SVG_pvs_adj')]
# object
}
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
run_Test2
?run_Test2
Test2 <- function(object, gene, K_test, lineage = 'lineage1'){
KList = object@kernel[[lineage]][setdiff(names(object@kernel[[lineage]]), c(K_test, 'kernel_error'))]
K_alt = object@kernel[[lineage]][[K_test]]
Y = object@gene_expression
Y = Y[gene,colnames(Y)[match(rownames(K_alt),colnames(Y))]]
n = length(Y)
if(!is.null(object@covariates )){
X <- object@covariates
}else{
X <- matrix(1, n, 1)
}
## parameter estimation
model.l <- gaston::lmm.aireml(Y = Y, X = X,K = KList,verbose = FALSE)
VCs <- c(model.l$tau, model.l$sigma2 );names(VCs) <- c(K_test, 'kernel_error')
## if directly use estimation (may try extract info from algo )
V_l <-  0
for(i in seq_along(KList)){
V_l <- V_l +  model.l$tau * KList[[i]]
}
V_l <- V_l + model.l$sigma2*object@kernel[[lineage]][['kernel_error']]
# V_l_inv <- invert(V_l)
V_l_inv <- inv(V_l)
P_l <- V_l_inv - V_l_inv%*%X%*% invert(t(X)%*%V_l_inv%*%X) %*%t(X)%*%V_l_inv
Q <- (t(Y) %*% P_l %*% K_alt %*% P_l%*% Y )/2
e <- TT(P_l, K_alt)/2
num_VC = length(KList) #number of VC in Null model
Ill_values <- c()
for(i in seq_along(KList)){
for(j in seq_along(KList)){
Ill_values <- c(Ill_values, TT(P_l %*% KList[[i]], P_l %*% KList[[j]]  ))
}
}
rm(model.l)
I_l_l <- matrix(Ill_values ,nrow = num_VC ,ncol = num_VC, byrow = TRUE )/2
Il_l <- matrix(unlist(lapply(KList, function(K){TT(P_l %*% K_alt, P_l %*% K )}))
,nrow = 1 ,ncol = num_VC, byrow = TRUE)/2
Ill <- TT(P_l %*% K_alt, P_l %*% K_alt )/2
Itt <- Ill-Il_l%*%pinv(I_l_l)%*%t(Il_l) #Ill_tilde
k <- Itt/e/2; v=2*e^2/Itt
pvalue <- pchisq(Q/k, df=v, lower.tail=F)
out <- list(gene = gene,VCs=VCs, Score=Q, df=v, scale=k, p.value=pvalue)
return(out)
}
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
#' @title Run Test2 for selected genes for one lineage
#' @param obejct  The TESSA object
#' @param genes The genes to do Test2. If NULL, then test all the uTSVGs
#' @param pv_threshold The pvalue threshold for test1, to get the uTSVGs that are significant in Test1
#' @param LOO If TRUE, run LOO double dipping correction for Test2
#' @param npcs The PC number to use in slingshot pseudotime estimation
#' @export
run_Test2_lineage = function(object, lineage = 'lineage1', genes = NULL, LOO = FALSE,npcs = 30){
meta_df <- na.omit(object@meta_df[,c('x','y',lineage,'Sample_ID')])
Y <- object@gene_expression[,colnames(object@gene_expression)[match(rownames(meta_df), colnames(object@gene_expression))],drop = FALSE]
if(!is.null(genes)){
cat('run Test2 on user defined ', length(genes) ,' uTSVGs on all lineages', '\n')
}else{
Test1_result <- get_Test1_result(object,lineage = lineage)
if('pvs_adj_LOO' %in% colnames(Test1_result)){
genes <- Test1_result$geneid[Test1_result$pvs_adj_LOO < 0.05 ]
cat('run Test2 on', length(genes) ,'uTSVGs', '\n')
}else{
genes <- Test1_result$geneid[Test1_result$pvs_adj < 0.05, ]
cat('run Test2 on', length(genes) ,'uTSVGs without double dipping correction', '\n')
}
}
if(LOO){
if("DP_genes" %in% names(object@result[[lineage]])){
DP_genes <- object@result[[lineage]]$DP_genes
}else{
DP_genes <- intersect(genes, object@signature_genes)
}
}
res_list <- list()
for(K_test_name in c( 'kernel_S', 'kernel_T')){
res <- lapply(genes, function(gene){
if(LOO & (K_test_name == 'kernel_T') & (gene %in% DP_genes)){
## only run LOO on TVGs detection, if this gene is used to estimate pseudotime
loc_df = meta_df
signature_genes <- setdiff(object@signature_genes, gene)
embedding <- prcomp_irlba(t(Y[signature_genes, ,drop = FALSE]), scale. = TRUE, n = npcs)$x
sim <- SingleCellExperiment(assays = Y,
reducedDims = SimpleList(PCA = embedding),
colData = DataFrame(clusterlabel = rep("0", ncol(Y)) )
)
sim  <- slingshot(sim, clusterLabels = 'clusterlabel', reducedDim = 'PCA',start.clus="0" )
loc_df[, lineage] = sim@colData@listData$slingPseudotime_1
object_loo <- CreateTessaObject(counts = Y[gene,,drop = FALSE ], meta_df = loc_df,
signature_genes =  signature_genes,
covariates = object@covariates, normalized = object@normalized )
object <- build_kernelMatrix(object_loo, bw = object@bandwidth)
test2_out <- Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}else{
test2_out <-Test2(object = object, gene = gene, K_test = K_test_name ,lineage = lineage)
}
test2_out
})
res <-  cbind( unlist(lapply(res, function(x){ x$p.value})),
unlist(lapply(res, function(x){ x$gene})) )
colnames(res) <-  c(K_test_name, 'geneid')
res_list[[K_test_name]] <- res
}
res_list
# res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
#   dplyr::rename('kernel_T' = 'TVG_pvs', 'kernel_S' = 'SVG_pvs') %>%
#   mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
#          SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
# object@result[[lineage]][['Test2']] <- res_df[,c('geneid', 'TVG_pvs', 'TVG_pvs_adj', 'SVG_pvs', 'SVG_pvs_adj')]
# object
}
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
devtools::load_all()
rm(list = c("run_Test2_lineage"))
devtools::load_all()
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
Tessa.obj
res_df = Tessa.obj
res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
dplyr::rename('TVG_pvs' = 'kernel_T', 'SVG_pvs' = 'kernel_S' ) %>%
mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
res_list = res_df
res_df <- full_join(data.frame(res_list [[1]]),data.frame(res_list[[2]]), by = "geneid")  %>%
dplyr::rename('TVG_pvs' = 'kernel_T', 'SVG_pvs' = 'kernel_S' ) %>%
mutate(TVG_pvs_adj = p.adjust(TVG_pvs, method = 'BY'),
SVG_pvs_adj = p.adjust(SVG_pvs, method = 'BY'))
res_df
res_df[,c('geneid', 'TVG_pvs', 'TVG_pvs_adj', 'SVG_pvs', 'SVG_pvs_adj')]
system.time(
Tessa.obj <-  run_Test1(Tessa.obj,LOO = FALSE, npcs = 10, LOO= F)
)
knitr::opts_chunk$set(echo = TRUE)
library(TESSA)
library(dplyr)
library(ggplot2)
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("SingleCellExperiment")
load('./data/PDAC_S2A.rda')
Tessa.obj =  CreateTessaObject(counts = counts, meta_df = meta_df,
signature_genes = mkgenes,
covariates = NULL, normalized = FALSE)
Tessa.obj = data_preprocess(object = Tessa.obj, spot.threshold = 10, gene.threshold = 0.1)
Tessa.obj = build_kernelMatrix(Tessa.obj)
## set npcs to a rational number automatically later
system.time(
Tessa.obj <-  run_Test1(Tessa.obj, LOO = TRUE, npcs = 10)
)
?RunPCA
uTSVGs_result <- get_Test1_result(Tessa.obj) %>% filter(pvs_adj_LOO < 0.05)
head(uTSVGs_result)
uTSVGs_list <- split(uTSVGs_result$geneid, uTSVGs_result$lineage)
str(uTSVGs_list)
library(Seurat)
#' @title Run Seurat PCA domain detection use selected features
#' @param seu.obj Spatial Seurat object
#' @param genes  Genes used as input features
#' @param names Name of the setting, used as domain name
#' @return return a seurat object with SeuratPCA domains, named as  paste0(names,'_seuratPCA)
runSeuratPCA = function(seu.obj, genes, names, clusternum = NULL,npcs = 30, verbose = FALSE,algorithm = 1){
if(class(seu.obj@images[[1]]) == 'VisiumV2'){
locations = GetTissueCoordinates(seu.st)[,c('x','y')]
colnames(locations) = c('row','col')
}else{
locations = seu.obj@images[[1]]@coordinates[,c('row','col')]
}
if (is.null(clusternum)){
if(!'ground_truth' %in% colnames(seu.obj@meta.data)) {
stop('please provide ground truth label in ground_truth column')
}
clusternum = length(unique(seu.obj$ground_truth[!is.na(seu.obj$ground_truth)]))
domain_name = paste0(names,'_seuratPCA')
}
if (names == 'hvg2000'){
seu.obj <- SCTransform(seu.obj, assay = "Spatial", verbose =  verbose, variable.features.n = 2000)
}else{ ## mkgenes
## return.only.var.genes: so scale.data return all genes, for cluster DE heatmap
seu.obj <- SCTransform(seu.obj, assay = "Spatial", verbose =  verbose, residual.features = NULL, return.only.var.genes = FALSE )
}
for(cl in clusternum){
domain_name = paste0(names,'_seuratPCA_', cl)
seu.obj <- RunPCA(seu.obj, assay = "SCT", verbose = FALSE, features = intersect(genes , rownames(seu.obj)),npcs = npcs)
seu.obj <- FindNeighbors(seu.obj,dims = 1:npcs,verbose = verbose)
best_res <- res_search(seu.obj, target_k = cl, algorithm = algorithm ,verbose = verbose)
seu.obj <- FindClusters(seu.obj,resolution = best_res, algorithm = algorithm, verbose = verbose)
seu.obj@meta.data[,domain_name]  = seu.obj$seurat_clusters
# seu.obj@meta.data[,paste0(domain_name,'_refined')] = refine_cluster_10x(clusterlabels=seu.obj@meta.data[,domain_name],
#               location=as.matrix(GetTissueCoordinates(seu.obj)[,c('x','y')]),shape="hexagon")
seu.obj@meta.data[,paste0(domain_name,'_refined')] = refine_cluster_10x(clusterlabels=seu.obj@meta.data[,domain_name],
location=as.matrix(locations),shape="hexagon")
}
seu.obj
}
lulibrary(Seurat)
library(Seurat)
seu.obj <- CreateSeuratObject(counts )
seu.obj <- SCTransform(seu.obj, assay = "RNA", verbose = F, residual.features = NULL, return.only.var.genes = FALSE )
seu.obj <- RunPCA(seu.obj, assay = "SCT", verbose = FALSE, features = intersect(uTSVGs , rownames(seu.obj)), reduction.name = "utsvg.pca")
## uTSVGs for each lineage
uTSVGs_list <- split(uTSVGs_result$geneid, uTSVGs_result$lineage)
str(uTSVGs_list)
## uTSVGs for all lineages
uTSVGs <- unique(unlist(uTSVGs_list))
seu.obj <- RunPCA(seu.obj, assay = "SCT", verbose = FALSE, features = intersect(uTSVGs , rownames(seu.obj)), reduction.name = "utsvg.pca")
seu.obj <- FindNeighbors(seu.obj, reduction = 'utsvg.pca', verbose = FALSE)
seu.obj <- FindClusters(seu.obj,resolution = 0.5, cluster.name = 'ustvg.cluster' ,verbose = FALSE)
seu.obj <- FindClusters(seu.obj,resolution = 0.5, cluster.name = 'ustvg.cluster' ,verbose = T)
seu.obj <- readRDS('./data/PDAC_S2A_seurat.rds')
seu.obj <- readRDS('./data/PDAC_S2A_seurat.rds')
seu.obj <- SCTransform(seu.obj, assay = "RNA", verbose = F, residual.features = NULL, return.only.var.genes = FALSE )
seu.obj <- readRDS('./data/PDAC_S2A_seurat.rds')
seu.obj <- SCTransform(seu.obj, assay = "Spatial", verbose = F, residual.features = NULL, return.only.var.genes = FALSE )
## uTSVGs based SeuratPCA domain analysis
seu.obj <- RunPCA(seu.obj, assay = "SCT", verbose = FALSE, features = intersect(uTSVGs , rownames(seu.obj)), reduction.name = "utsvg.pca")
seu.obj <- FindNeighbors(seu.obj, reduction = 'utsvg.pca', verbose = FALSE)
seu.obj <- FindClusters(seu.obj,resolution = 0.5, cluster.name = 'ustvg.cluster' ,verbose = F)
seu.obj <- FindClusters(seu.obj,resolution = 0.5, cluster.name = 'utsvg.cluster' ,verbose = F)
?FindClusters
SpatialDimPlot(seu.obj, group.by = 'utsvg.cluster')
seu.obj <- FindClusters(seu.obj, resolution = 0.45, graph.name = 'utsvg.pca', cluster.name = 'utsvg.cluster' ,verbose = T)
seu.obj <- FindClusters(seu.obj, resolution = 0.45, graph.name = 'utsvg.pca', cluster.name = 'utsvg.cluster' ,verbose = T)
str(seu.obj )
seu.obj <- FindNeighbors(seu.obj, reduction = 'utsvg.pca', verbose = FALSE)
str(seu.obj)
seu.obj <- FindNeighbors(seu.obj, reduction = 'utsvg.pca', graph.name = 'utsvg.nn', verbose = FALSE)
seu.obj <- FindClusters(seu.obj, resolution = 0.45, graph.name = 'utsvg.nn', cluster.name = 'utsvg.cluster' ,verbose = T)
seu.obj <- FindClusters(seu.obj, resolution = 0.5, graph.name = 'utsvg.nn', cluster.name = 'utsvg.cluster' ,verbose = T)
seu.obj <- FindClusters(seu.obj, resolution = 0.55, graph.name = 'utsvg.nn', cluster.name = 'utsvg.cluster' ,verbose = T)
SpatialDimPlot(seu.obj, group.by = 'utsvg.cluster')
SpatialDimPlot(seu.obj, group.by = 'utsvg.cluster',pt.size =2)
paperColors =c("gold", "skyblue", "orchid4", "#868603", "royalblue2","darkorange",  "violet",'cyan','#6c0404',
"#90bca6","#bbca81","#f1f9c7","#efc8c2","#6EA0B8","#5c92b6","#e2c987")
SpatialDimPlot(seu.obj, group.by = 'utsvg.cluster',pt.size =2,cols = paperColors)
cols =c("gold", "skyblue", "orchid4", "#868603", "royalblue2","darkorange",  "violet",'cyan','#6c0404',
"#90bca6","#bbca81","#f1f9c7","#efc8c2","#6EA0B8","#5c92b6","#e2c987")
names(cols) = levels(seu.obj$utsvg.cluster)
SpatialDimPlot(seu.obj, group.by = 'utsvg.cluster',pt.size =2,cols = cols)
HVGs <- VariableFeatures(seu.obj)
## HVG based SeuratPCA domain analysis
seu.obj <- RunPCA(seu.obj, assay = "SCT", verbose = FALSE, features = intersect(HVGs , rownames(seu.obj)), reduction.name = "hvg.pca")
seu.obj <- FindNeighbors(seu.obj, reduction = 'hvg.pca', graph.name = 'hvg.nn', verbose = FALSE)
seu.obj <- FindClusters(seu.obj, resolution = 0.55, graph.name = 'hvg.nn', cluster.name = 'hvg.cluster' ,verbose = T)
SpatialDimPlot(seu.obj, group.by = 'hvg.cluster',pt.size = 2,cols = cols)
system.time(
Tessa.obj <-  run_Test2_lineage(Tessa.obj, LOO = TRUE,lineage = 'lineage1',genes = c("HES4", "ISG15"))
)
run_Test2_lineage
devtools::load_all()
